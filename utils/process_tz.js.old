

var fs = require('fs');
var path = require('path');
var util = require('util');
var mkdirp = require('mkdirp');
var geolib = require('geolib');
var bbox = require('geojson-bbox');
var asynclib = require('async');
var nodedir = require('node-dir');
var tc = require('timezonecomplete');
var momentTZ = require('moment-timezone');

var tzDb = tc.TzDatabase.instance();

var args = process.argv.slice(2);

var combinedGeoJson = require('./dist/combined.json');
var outDir = './out/';

var currentYear = new Date().getFullYear();


var saveGeometry = function(feature, callback) {
    var properties = feature['properties'];
    var geometry = feature['geometry'];
    var tzId = properties['tzid'];
    var fileName = path.join(outDir, tzId.replace(/\//g, '__') + '.json');
    console.log('saving', tzId);

    fs.writeFile(fileName, JSON.stringify(geometry), callback);
};

var scanDir = function(dir, callback) {
    nodedir.readFiles(dir, {
	recursive:  false,
	match:      /.json$/
    }, function(err, content, file, next) {
	var json = JSON.parse(content);
	processGeoJSON(file, json);
	next();
    }, callback);
};

var processGeoJSON = function(file, data) {
    var geomType = data['type'];
    var coordinates = data['coordinates'];
    var baseName = path.basename(file, '.json');
    var bounds;

    switch(geomType) {
    case 'MultiPolygon':
	bounds = processMultiPolygon(coordinates);
	break;
    case 'Polygon':
	bounds = processPolygon(coordinates);
	break;
    default:
	console.log('unsupported geometry type:', geomType);
	return;
    }

    var p1 = bounds[0];
    var p2 = bounds[1];
    var gp1 = [p1.longitude, p1.latitude];
    var gp2 = [p2.longitude, p2.latitude];
    var boundsArr = [gp1, gp2];
    var boundsArr1 = bbox(data);
    //var zoneName = baseName.split('.')[0];
    //var tzId = getTZID(zoneName);
    var tzId = baseName.replace(/__/g, '/');
    var tzData = getTZData(tzId);
    console.log(boundsArr);
    console.log(boundsArr1);

    data['bbox'] = boundsArr;
    data['tz'] = tzData;

    saveFile(file, boundsArr, data);
};

var saveFile = function(file, bounds, data) {
    var p1 = bounds[0];
    var p2 = bounds[1];
    var maxLat = p1[1];
    var minLng = p1[0];
    var minLat = p2[1];
    var maxLng = p2[0];
    var fileName = util.format('%s%s%s%s.json',
			       zeroPad(Math.abs(parseInt(maxLat) + 1), 2),
			       zeroPad(Math.abs(parseInt(minLng) + 1), 3),
			       zeroPad(Math.abs(parseInt(minLat) + 1), 2),
			       zeroPad(Math.abs(parseInt(maxLng) + 1), 3));

    var paths = getPath(minLat, maxLat, minLng, maxLng);
    console.log('save', file, ' to ', paths, ' / ', fileName);

    for(var i = 0, l = paths.length; i < l; i++) {
	var dir = paths[i];

	dir = path.join(outDir, dir);

	mkdirp.mkdirp.sync(dir);

	var newPath = path.join(dir, fileName);

	fs.writeFileSync(file, JSON.stringify(data));
	fs.renameSync(file, newPath);
    }
};

var getPath = function(minLat, maxLat, minLng, maxLng) {
    var path = [];

    if(minLat >= 0 && maxLat >= 0) {
	// north hemisphere
	if(minLng >= 0 && maxLng >= 0) {
	    // east hemisphere
	    path.push('N/E');
	} else if(minLng < 0 && maxLng < 0) {
	    // west hemisphere
	    path.push('N/W');
	} else {
	    // both hemispheres
	    path.push('N/E', 'N/W');
	}
    } else if(minLat < 0 && maxLat < 0) {
	// south hemisphere
	if(minLng >= 0 && maxLng >= 0) {
	    // east hemisphere
	    path.push('S/E');
	} else if(minLng < 0 && maxLng < 0) {
	    // west hemisphere
	    path.push('S/W');
	} else {
	    // both hemispheres
	    path.push('S/E', 'S/W');
	}
    } else {
	// both hemispheres
	if(minLng >= 0 && maxLng >= 0) {
	    // east hemisphere
	    path.push('N/E', 'S/E');
	} else if(minLng < 0 && maxLng < 0) {
	    // west hemisphere
	    path.push('N/W', 'S/W');
	} else {
	    // both hemispheres
	    path.push('N/E', 'S/E', 'S/E', 'S/W');
	}
    }

    return path;
};

var processMultiPolygon = function(multiPolygon) {
    var arr = [];

    for(var i = 0, l = multiPolygon.length; i < l; i++) {
	var polygon = multiPolygon[i];
	var b = processPolygon(polygon);

	arr.push(b[0], b[1]);
    }

    var bounds = geolib.getBounds(arr);
    var p1 = {
	latitude:  bounds.maxLat,
	longitude: bounds.minLng
    };
    var p2 = {
	latitude:  bounds.minLat,
	longitude: bounds.maxLng
    };
    var boundsArr = [p1, p2];

    return boundsArr;
};

var processPolygon = function(polygon) {
    var arr = [];

    for(var i = 0, l = polygon.length; i < l; i++) {
	var line = polygon[i];
	var b = processLine(line);

	arr.push(b[0], b[1]);
    }

    var bounds = geolib.getBounds(arr);
    var p1 = {
	latitude:  bounds.maxLat,
	longitude: bounds.minLng
    };
    var p2 = {
	latitude:  bounds.minLat,
	longitude: bounds.maxLng
    };
    var boundsArr = [p1, p2];

    return boundsArr;
};

var processLine = function(line) {
    var bounds = geolib.getBounds(line);
    var p1 = {
	latitude:  bounds.maxLat,
	longitude: bounds.minLng
    };
    var p2 = {
	latitude:  bounds.minLat,
	longitude: bounds.maxLng
    };
    var boundsArr = [p1, p2];

    return boundsArr;
};


var getTZData = function(tzId) {
    var zoneInfo = momentTZ.tz.zone(tzId);
    var wTime = momentTZ([currentYear, 01, 01]).tz(tzId);
    var sTime = momentTZ([currentYear, 07, 01]).tz(tzId);
    var dstOffAbbr = wTime.zoneAbbr();
    var dstOnAbbr = sTime.zoneAbbr();
    var dstOffOffset = parseInt(wTime.utcOffset()) * 60;
    var abbrs = [dstOffAbbr];
    var offsets = [dstOffOffset];
    var change = [];

    if(dstOffAbbr !== dstOnAbbr) {
	abbrs.push(dstOnAbbr);
	offsets.push(parseInt(sTime.utcOffset()) * 60);

	try {
	    change.push(tzDb.nextDstChange(tzId, wTime.utc().valueOf()),
			tzDb.nextDstChange(tzId, sTime.utc().valueOf()));
	} catch (e) {
	    console.log(e);
	}
    }

    return {
	name:  tzId,
	dstRules: {
	    abbrs:    abbrs,
	    offsets:  offsets,
	    change:   change
	}
    };
};


var safeMkdir = function(dirname, callback) {
    fs.mkdir(dirname, function(err) {
	if(err && err.code === 'EEXIST') {
	    callback();
	} else {
	    callback(err);
	}
    })
};

var writeVersion = function(callback) {
    var fileName = path.join(outDir, 'version');
    var date = momentTZ().format('YYYYMMDD');

    fs.writeFile(fileName, date, callback);
};


var zeroPad = function(num, size) {
    return ('000000000' + num).substr(-size);
};



//=======================================================================

asynclib.auto({
    createDir: function(cb) {
	console.log('create directory');
	safeMkdir(outDir, cb);
    },
    splitGeoJSON: ['createDir', function(results, cb) {
	console.log('split GeoJSON...');
	asynclib.eachSeries(combinedGeoJson['features'], saveGeometry, cb)
    }],
    processGeojson: ['splitGeoJSON', function(results, cb) {
	console.log('process TZ data files...');
	scanDir(outDir, cb);
    }],
    saveVersion: ['processGeojson', function(results, cb) {
	console.log('write version...');
	writeVersion(cb);
    }]
}, function(err) {
    console.log('complete.');

    if(err) {
	console.log(err);
	return;
    }
});

